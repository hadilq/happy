package com.github.hadilq.happy.processor.common.generate

import com.github.hadilq.happy.annotation.Happy
import com.github.hadilq.happy.annotation.HappyDslMaker
import com.github.hadilq.happy.processor.common.di.HappyProcessorModule
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy

public fun HappyProcessorModule.generateHappyFile(
  sealedParentHType: CommonHType,
  happyHType: CommonHType,
): GenerateHappyFile {
  val otherwiseBuilderName = "${sealedParentHType.simpleNames.joinToString("")}$OTHERWISE_BUILDER"

  val classBuilder = TypeSpec.classBuilder(otherwiseBuilderName)
    .addAnnotation(HappyDslMaker::class)
    .addTypeVariables(sealedParentHType.typeParameters)
    .primaryConstructor(
      FunSpec.constructorBuilder()
        .addParameter(SEALED_PROPERTY_NAME, sealedParentHType.className)
        .build()
    )
    .addProperty(
      PropertySpec.builder(SEALED_PROPERTY_NAME, sealedParentHType.className)
        .initializer(SEALED_PROPERTY_NAME)
        .build()
    )
    .addProperty(
      PropertySpec.builder(RESULT_VAR_NAME, happyHType.className, KModifier.PUBLIC, KModifier.LATEINIT)
        .mutable(true)
        .build()
    )

  val cases = findCases(sealedParentHType, happyHType).toList()
  cases
    .asSequence()
    .generateBuilderFunctions(happyHType)
    .forEach { generatedFunction ->
      val fn = generatedFunction.elvis {
        return GenerateHappyFile.Failure(it)
      }
      classBuilder.addFunction(fn.function)
    }

  val otherwiseFunBuilder = FunSpec.builder(OTHERWISE)
    .addModifiers(KModifier.PUBLIC)
    .addModifiers(KModifier.INFIX)
    .addModifiers(KModifier.INLINE)
    .addTypeVariables(sealedParentHType.typeParameters)
    .receiver(sealedParentHType.className)
    .returns(happyHType.className)

  val justTwoCases = classBuilder.funSpecs.size == 1
  if (justTwoCases) {
    val justTwoCasesFun = classBuilder.funSpecs[0]
    otherwiseFunBuilder
      .addParameter(justTwoCasesFun.parameters[0])
      .addCode(
        CodeBlock.of(
          """
            if (this is %T) {
              return this
            }
            val $SEALED_PROPERTY_NAME = this
            var $RESULT_VAR_NAME: %T? = null

          """.trimIndent(), happyHType.className, happyHType.className
        )
      )
      .addCode(justTwoCasesFun.body)
      .addStatement("")
      .addStatement("return $RESULT_VAR_NAME!!")
  } else {
    val buildFunName = "build"
    val builderClassName =
      if (sealedParentHType.typeParameters.isNotEmpty()) {
        ClassName(sealedParentHType.packageName, otherwiseBuilderName)
          .parameterizedBy(sealedParentHType.typeParameters)
      } else {
        ClassName(sealedParentHType.packageName, otherwiseBuilderName)
      }
    otherwiseFunBuilder.addParameter(
      buildFunName, LambdaTypeName.get(
        receiver = builderClassName,
        returnType = Unit::class.asTypeName()
      )
    ).addCode(
      CodeBlock.of(
        """
          if (this is %T) {
            return this
          } else {
            val builder = $otherwiseBuilderName(this)
            builder.$buildFunName()
            return builder.result
          }
        """.trimIndent(), happyHType.className
      )
    )
  }

  val elvisFunBuilder = generateElvisFunction(sealedParentHType, happyHType, cases)

  if (happyHType.isInternal) {
    classBuilder.addModifiers(KModifier.INTERNAL)
    otherwiseFunBuilder.addModifiers(KModifier.INTERNAL)
    elvisFunBuilder.addModifiers(KModifier.INTERNAL)
  }

  val typeSpec = classBuilder.build()
  val otherwiseFunSpec = otherwiseFunBuilder.build()
  val elvisFunSpec = elvisFunBuilder.build()

  val fileSpecBuilder = FileSpec.builder(sealedParentHType.packageName, otherwiseBuilderName)
    .indent("  ")
    .addComment("Code generated by happy processor. Do not edit.")
    .addFunction(otherwiseFunSpec)
    .addFunction(elvisFunSpec)

  if (!justTwoCases) {
    fileSpecBuilder.addType(typeSpec)
  }

  return GenerateHappyFile.File(fileSpecBuilder.build())
}

public sealed interface GenerateHappyFile {
  @Happy
  public data class File(
    public val fileSpec: FileSpec,
  ) : GenerateHappyFile

  public data class Failure(
    public val reason: GenerateBuilderFunction.Failure,
  ) : GenerateHappyFile
}
