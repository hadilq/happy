/*
 * Copyright 2021 Hadi Lashkari Ghouchani
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
package com.github.hadilq.happy.processor.generate

import com.github.hadilq.happy.annotation.HappyDslMaker
import com.github.hadilq.happy.processor.di.HappyProcessorModule
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.metadata.ImmutableKmClass
import com.squareup.kotlinpoet.metadata.KotlinPoetMetadataPreview
import com.squareup.kotlinpoet.metadata.isInternal
import javax.lang.model.element.TypeElement

private const val OTHERWISE = "elseIf"
private const val OTHERWISE_BUILDER = "ElseIfBuilder"

@KotlinPoetMetadataPreview
public fun HappyProcessorModule.generateHappyFile(
  sealedParentKmClass: ImmutableKmClass,
  happyType: TypeElement,
  happyKmClass: ImmutableKmClass,
): Result<FileSpec> {
  val sealedParentClassName = sealedParentKmClass.className
  val happyClassName = happyKmClass.className
  val otherwiseBuilderName = "${sealedParentClassName.simpleNames.joinToString("")}$OTHERWISE_BUILDER"
  val sealedPropertyName = "parent"
  val resultVarName = "result"

  val classBuilder = TypeSpec.classBuilder(otherwiseBuilderName)
    .addAnnotation(HappyDslMaker::class)
    .primaryConstructor(
      FunSpec.constructorBuilder()
        .addParameter(sealedPropertyName, sealedParentClassName)
        .build()
    )
    .addProperty(
      PropertySpec.builder(sealedPropertyName, sealedParentClassName)
        .initializer(sealedPropertyName)
        .build()
    )
    .addProperty(
      PropertySpec.builder(resultVarName, happyClassName, KModifier.PUBLIC, KModifier.LATEINIT)
        .mutable(true)
        .build()
    )

  generateBuilderFunctions(sealedParentKmClass, happyType, happyKmClass, sealedPropertyName, resultVarName)
    .forEach {
      val funSpec = it.getOrNull() ?: return Result.failure(it.exceptionOrNull()!!)
      classBuilder.addFunction(funSpec)
    }

  val funBuilder = FunSpec.builder(OTHERWISE)
    .addModifiers(KModifier.PUBLIC)
    .addModifiers(KModifier.INFIX)
    .addModifiers(KModifier.INLINE)
    .receiver(sealedParentClassName)
    .returns(happyClassName)

  val justTwoCases = classBuilder.funSpecs.size == 1
  if (justTwoCases) {
    val justTwoCasesFun = classBuilder.funSpecs[0]
    funBuilder
      .addParameter(justTwoCasesFun.parameters[0])
      .addCode(
        CodeBlock.of(
          """
            if (this is %T) {
              return this
            }
            val $sealedPropertyName = this
            var $resultVarName: %T? = null

          """.trimIndent(), happyType, happyType
        )
      )
      .addCode(justTwoCasesFun.body)
      .addStatement("")
      .addStatement("return $resultVarName!!")
  } else {
    val buildFunName = "build"
    funBuilder.addParameter(
      buildFunName, LambdaTypeName.get(
        receiver = ClassName(sealedParentClassName.packageName, otherwiseBuilderName),
        returnType = Unit::class.asTypeName()
      )
    ).addCode(
      CodeBlock.of(
        """
          if (this is %T) {
            return this
          } else {
            val builder = $otherwiseBuilderName(this)
            builder.$buildFunName()
            return builder.result
          }
        """.trimIndent(), happyType
      )
    )
  }

  if (happyKmClass.isInternal) {
    classBuilder.addModifiers(KModifier.INTERNAL)
    funBuilder.addModifiers(KModifier.INTERNAL)
  }

  val typeSpec = classBuilder.build()
  val funSpec = funBuilder.build()

  val fileSpecBuilder = FileSpec.builder(sealedParentClassName.packageName, otherwiseBuilderName)
    .indent("  ")
    .addComment("Code generated by happy processor. Do not edit.")
    .addFunction(funSpec)

  if (!justTwoCases) {
    fileSpecBuilder.addType(typeSpec)
  }

  return Result.success(fileSpecBuilder.build())
}
