/*
 * Copyright 2021 Hadi Lashkari Ghouchani
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
package com.github.hadilq.happy.processor.generate

import com.github.hadilq.happy.annotation.HappyDslMaker
import com.github.hadilq.happy.processor.HType
import com.github.hadilq.happy.processor.di.HappyProcessorModule
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.metadata.KotlinPoetMetadataPreview
import com.squareup.kotlinpoet.metadata.isInternal

@KotlinPoetMetadataPreview
public fun HappyProcessorModule.generateHappyFile(
  sealedParentHType: HType,
  happyHType: HType,
): Result<FileSpec> {
  val otherwiseBuilderName = "${sealedParentHType.simpleNames.joinToString("")}$OTHERWISE_BUILDER"

  val classBuilder = TypeSpec.classBuilder(otherwiseBuilderName)
    .addAnnotation(HappyDslMaker::class)
    .addTypeVariables(sealedParentHType.typeParameters)
    .primaryConstructor(
      FunSpec.constructorBuilder()
        .addParameter(SEALED_PROPERTY_NAME, sealedParentHType.className)
        .build()
    )
    .addProperty(
      PropertySpec.builder(SEALED_PROPERTY_NAME, sealedParentHType.className)
        .initializer(SEALED_PROPERTY_NAME)
        .build()
    )
    .addProperty(
      PropertySpec.builder(RESULT_VAR_NAME, happyHType.className, KModifier.PUBLIC, KModifier.LATEINIT)
        .mutable(true)
        .build()
    )

  val cases = findCases(sealedParentHType, happyHType).toList()
  generateBuilderFunctions(happyHType, cases)
    .forEach {
      val funSpec = it.getOrNull() ?: return Result.failure(it.exceptionOrNull()!!)
      classBuilder.addFunction(funSpec)
    }

  val otherwiseFunBuilder = FunSpec.builder(OTHERWISE)
    .addModifiers(KModifier.PUBLIC)
    .addModifiers(KModifier.INFIX)
    .addModifiers(KModifier.INLINE)
    .addTypeVariables(sealedParentHType.typeParameters)
    .receiver(sealedParentHType.className)
    .returns(happyHType.className)

  val justTwoCases = classBuilder.funSpecs.size == 1
  if (justTwoCases) {
    val justTwoCasesFun = classBuilder.funSpecs[0]
    otherwiseFunBuilder
      .addParameter(justTwoCasesFun.parameters[0])
      .addCode(
        CodeBlock.of(
          """
            if (this is %T) {
              return this
            }
            val $SEALED_PROPERTY_NAME = this
            var $RESULT_VAR_NAME: %T? = null

          """.trimIndent(), happyHType.className, happyHType.className
        )
      )
      .addCode(justTwoCasesFun.body)
      .addStatement("")
      .addStatement("return $RESULT_VAR_NAME!!")
  } else {
    val buildFunName = "build"
    val builderClassName =
      if (sealedParentHType.typeParameters.isNotEmpty()) {
        ClassName(sealedParentHType.packageName, otherwiseBuilderName)
          .parameterizedBy(sealedParentHType.typeParameters)
      } else {
        ClassName(sealedParentHType.packageName, otherwiseBuilderName)
      }
    otherwiseFunBuilder.addParameter(
      buildFunName, LambdaTypeName.get(
        receiver = builderClassName,
        returnType = Unit::class.asTypeName()
      )
    ).addCode(
      CodeBlock.of(
        """
          if (this is %T) {
            return this
          } else {
            val builder = $otherwiseBuilderName(this)
            builder.$buildFunName()
            return builder.result
          }
        """.trimIndent(), happyHType.className
      )
    )
  }

  val elvisFunBuilder = generateElvisFunction(sealedParentHType, happyHType, cases)

  if (happyHType.meta.flags.isInternal) {
    classBuilder.addModifiers(KModifier.INTERNAL)
    otherwiseFunBuilder.addModifiers(KModifier.INTERNAL)
    elvisFunBuilder.addModifiers(KModifier.INTERNAL)
  }

  val typeSpec = classBuilder.build()
  val otherwiseFunSpec = otherwiseFunBuilder.build()
  val elvisFunSpec = elvisFunBuilder.build()

  val fileSpecBuilder = FileSpec.builder(sealedParentHType.packageName, otherwiseBuilderName)
    .indent("  ")
    .addComment("Code generated by happy processor. Do not edit.")
    .addFunction(otherwiseFunSpec)
    .addFunction(elvisFunSpec)

  if (!justTwoCases) {
    fileSpecBuilder.addType(typeSpec)
  }

  return Result.success(fileSpecBuilder.build())
}

private const val OTHERWISE = "elseIf"
private const val OTHERWISE_BUILDER = "ElseIfBuilder"
internal const val ELVIS = "elvis"
internal const val BLOCK_NAME = "block"
internal const val SEALED_PROPERTY_NAME = "parent"
internal const val RESULT_VAR_NAME = "result"

