/*
 * Copyright 2021 Hadi Lashkari Ghouchani
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
package com.github.hadilq.happy.processor

import com.google.common.truth.Truth.assertThat
import com.squareup.kotlinpoet.metadata.KotlinPoetMetadataPreview
import com.tschuchort.compiletesting.KotlinCompilation
import com.tschuchort.compiletesting.SourceFile
import org.junit.Test
import java.io.File

@KotlinPoetMetadataPreview
class HappyProcessorTest {

  @Test
  fun twoOptionTest() {
    val sourceFileName = "ASealedClass.kt"
    val sourceCode = """
      package test
      import com.github.hadilq.happy.`annotation`.Happy

      sealed class A {
        @Happy
        class HappyA : A()
        class FailedA : A()
      }
    """
    val generatedFileName = "test/AElseIfBuilder.kt"
    val generatedCode = """
      // Code generated by happy processor. Do not edit.
      package test

      public inline infix fun A.elseIf(block: () -> A.HappyA): A.HappyA {
        if (this is A.HappyA) {
          return this
        }
        val parent = this
        var result: A.HappyA? = null
        if(parent is A.FailedA) {
          result = block()
        }
        return result!!
      }
    """.trimIndent()
    doTest(sourceFileName, sourceCode, generatedFileName, generatedCode)
  }

  @Test
  fun threeOptionTest() {
    val sourceFileName = "ASealedClass.kt"
    val sourceCode = """
      package test
      import com.github.hadilq.happy.`annotation`.Happy

      sealed class A {
        @Happy
        class HappyA : A()
        class OptionOne : A()
        class OptionTwo : A()
      }
    """
    val generatedFileName = "test/AElseIfBuilder.kt"
    val generatedCode = """
      // Code generated by happy processor. Do not edit.
      package test

      import com.github.hadilq.happy.`annotation`.HappyDslMaker
      import kotlin.Unit

      public inline infix fun A.elseIf(build: AElseIfBuilder.() -> Unit): A.HappyA {
        if (this is A.HappyA) {
          return this
        } else {
          val builder = AElseIfBuilder(this)
          builder.build()
          return builder.result
        }
      }

      @HappyDslMaker
      public class AElseIfBuilder(
        public val parent: A
      ) {
        public lateinit var result: A.HappyA

        public inline fun OptionOne(block: () -> A.HappyA): Unit {
          if(parent is A.OptionOne) {
            result = block()
          }
        }

        public inline fun OptionTwo(block: () -> A.HappyA): Unit {
          if(parent is A.OptionTwo) {
            result = block()
          }
        }
      }
    """.trimIndent()
    doTest(sourceFileName, sourceCode, generatedFileName, generatedCode)
  }

  @Test
  fun twoOptionDataOneParamTest() {
    val sourceFileName = "ASealedClass.kt"
    val sourceCode = """
      package test
      import com.github.hadilq.happy.`annotation`.Happy

      sealed class A {
        @Happy
        data class HappyA(val happy : Int) : A()
        data class FailedA(val failed : Int) : A()
      }
    """
    val generatedFileName = "test/AElseIfBuilder.kt"
    val generatedCode = """
      // Code generated by happy processor. Do not edit.
      package test

      import kotlin.Int

      public inline infix fun A.elseIf(block: (failed: Int) -> A.HappyA): A.HappyA {
        if (this is A.HappyA) {
          return this
        }
        val parent = this
        var result: A.HappyA? = null
        if(parent is A.FailedA) {
          result = block(parent.failed)
        }
        return result!!
      }
    """.trimIndent()
    doTest(sourceFileName, sourceCode, generatedFileName, generatedCode)
  }

  @Test
  fun threeOptionDataOneParamTest() {
    val sourceFileName = "ASealedClass.kt"
    val sourceCode = """
      package test
      import com.github.hadilq.happy.`annotation`.Happy

      sealed class A {
        @Happy
        data class HappyA(val happy : Int) : A()
        data class OptionOne(val one : Int) : A()
        data class OptionTwo(val two : Int) : A()
      }
    """
    val generatedFileName = "test/AElseIfBuilder.kt"
    val generatedCode = """
      // Code generated by happy processor. Do not edit.
      package test

      import com.github.hadilq.happy.`annotation`.HappyDslMaker
      import kotlin.Int
      import kotlin.Unit

      public inline infix fun A.elseIf(build: AElseIfBuilder.() -> Unit): A.HappyA {
        if (this is A.HappyA) {
          return this
        } else {
          val builder = AElseIfBuilder(this)
          builder.build()
          return builder.result
        }
      }

      @HappyDslMaker
      public class AElseIfBuilder(
        public val parent: A
      ) {
        public lateinit var result: A.HappyA

        public inline fun OptionOne(block: (one: Int) -> A.HappyA): Unit {
          if(parent is A.OptionOne) {
            result = block(parent.one)
          }
        }

        public inline fun OptionTwo(block: (two: Int) -> A.HappyA): Unit {
          if(parent is A.OptionTwo) {
            result = block(parent.two)
          }
        }
      }
    """.trimIndent()
    doTest(sourceFileName, sourceCode, generatedFileName, generatedCode)
  }

  @Test
  fun twoOptionDataMixedTest() {
    val sourceFileName = "ASealedClass.kt"
    val sourceCode = """
      package test
      import com.github.hadilq.happy.`annotation`.Happy

      sealed class A(val a : Int) {
        @Happy
        data class HappyA(val happy : Int) : A(happy)
        object FailedA : A(-1)
      }
    """
    val generatedFileName = "test/AElseIfBuilder.kt"
    val generatedCode = """
      // Code generated by happy processor. Do not edit.
      package test

      public inline infix fun A.elseIf(block: () -> A.HappyA): A.HappyA {
        if (this is A.HappyA) {
          return this
        }
        val parent = this
        var result: A.HappyA? = null
        if(parent is A.FailedA) {
          result = block()
        }
        return result!!
      }
    """.trimIndent()
    doTest(sourceFileName, sourceCode, generatedFileName, generatedCode)
  }

  @Test
  fun threeOptionDataMixedTest() {
    val sourceFileName = "ASealedClass.kt"
    val sourceCode = """
      package test
      import com.github.hadilq.happy.`annotation`.Happy

      sealed class A(val a : Int) {
        @Happy
        data class HappyA(val happy : Int) : A(happy)
        object OptionOne : A(Int.MAX_VALUE)
        data class OptionTwo(val one : Int, val two : Int, val three : Int) : A(one)
      }
    """
    val generatedFileName = "test/AElseIfBuilder.kt"
    val generatedCode = """
      // Code generated by happy processor. Do not edit.
      package test

      import com.github.hadilq.happy.`annotation`.HappyDslMaker
      import kotlin.Int
      import kotlin.Unit

      public inline infix fun A.elseIf(build: AElseIfBuilder.() -> Unit): A.HappyA {
        if (this is A.HappyA) {
          return this
        } else {
          val builder = AElseIfBuilder(this)
          builder.build()
          return builder.result
        }
      }

      @HappyDslMaker
      public class AElseIfBuilder(
        public val parent: A
      ) {
        public lateinit var result: A.HappyA

        public inline fun OptionOne(block: () -> A.HappyA): Unit {
          if(parent is A.OptionOne) {
            result = block()
          }
        }

        public inline fun OptionTwo(block: (
          one: Int,
          two: Int,
          three: Int
        ) -> A.HappyA): Unit {
          if(parent is A.OptionTwo) {
            result = block(parent.one, parent.two, parent.three)
          }
        }
      }
    """.trimIndent()
    doTest(sourceFileName, sourceCode, generatedFileName, generatedCode)
  }

  private fun doTest(
    sourceFileName: String,
    sourceCode: String,
    generatedFileName: String,
    generatedCode: String
  ) {
    val source = SourceFile.kotlin(
      sourceFileName,
      sourceCode
    )

    val compilation = KotlinCompilation().apply {
      sources = listOf(source)
      inheritClassPath = true
      annotationProcessors = listOf(HappyProcessor())
    }
    val result = compilation.compile()
    assertThat(result.exitCode).isEqualTo(KotlinCompilation.ExitCode.OK)
    val generatedSourcesDir = compilation.kaptSourceDir
    val generatedFile = File(generatedSourcesDir, generatedFileName)
    assertThat(generatedFile.exists()).isTrue()
    //language=kotlin
    assertThat(generatedFile.readText().trim()).isEqualTo(
      generatedCode
    )
  }
}